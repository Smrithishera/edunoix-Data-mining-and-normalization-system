# -*- coding: utf-8 -*-
"""Data mining and normalization system.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1v5i9Z_LhjI2OFVfEyCEeXdxXuOM2hNrC
"""

import tensorflow as tf
from tensorflow.keras import datasets, layers, models

# Load the MNIST dataset
(x_train, y_train), (x_test, y_test) = datasets.mnist.load_data()

# Reshape data to include a channel dimension (for grayscale images)
x_train = x_train.reshape(x_train.shape[0], 28, 28, 1)
x_test = x_test.reshape(x_test.shape[0], 28, 28, 1)

# Normalize image data to range [0, 1]
x_train, x_test = x_train / 255.0, x_test / 255.0

# Convert labels to integers
y_train = y_train.astype(int)
y_test = y_test.astype(int)

# Print the shape of an image and its channels
print(f"Image shape: {x_train[0].shape}")
print(f"Image channels: {x_train.shape[-1]}")

# Create a Sequential model
model = models.Sequential()

# Add first Conv2D layer: 32 units, 3x3 kernel size, relu activation
model.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=(28, 28, 1)))

# Add second Conv2D layer: 64 units, relu activation
model.add(layers.Conv2D(64, (3, 3), activation='relu'))

# Add MaxPooling2D layer: 2x2 pooling size
model.add(layers.MaxPooling2D((2, 2)))

# Flatten the output from the Conv layers for the dense layers
model.add(layers.Flatten())

# Add standard Dense (input, hidden) layers
model.add(layers.Dense(128, activation='relu'))  # Hidden layer with 128 units

# Output layer with 10 units (one for each class)
model.add(layers.Dense(10, activation='softmax'))

# Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Train the model on the training data
model.fit(x_train, y_train, epochs=5, batch_size=32, validation_data=(x_test, y_test))

# Evaluate the model and save the output into a variable
evaluation = model.evaluate(x_test, y_test)
print(f"Test loss: {evaluation[0]}")
print(f"Test accuracy: {evaluation[1]}")

# Save the model evaluation output
test_loss, test_accuracy = evaluation